// Code generated by protoc-gen-go.
// source: hsm.proto
// DO NOT EDIT!

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type XPub struct {
	Alias string `protobuf:"bytes,1,opt,name=alias" json:"alias,omitempty"`
	Xpub  []byte `protobuf:"bytes,2,opt,name=xpub,proto3" json:"xpub,omitempty"`
}

func (m *XPub) Reset()                    { *m = XPub{} }
func (m *XPub) String() string            { return proto.CompactTextString(m) }
func (*XPub) ProtoMessage()               {}
func (*XPub) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *XPub) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *XPub) GetXpub() []byte {
	if m != nil {
		return m.Xpub
	}
	return nil
}

type CreateKeyRequest struct {
	Alias string `protobuf:"bytes,1,opt,name=alias" json:"alias,omitempty"`
}

func (m *CreateKeyRequest) Reset()                    { *m = CreateKeyRequest{} }
func (m *CreateKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateKeyRequest) ProtoMessage()               {}
func (*CreateKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *CreateKeyRequest) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type CreateKeyResponse struct {
	Xpub  *XPub  `protobuf:"bytes,1,opt,name=xpub" json:"xpub,omitempty"`
	Error *Error `protobuf:"bytes,9,opt,name=error" json:"error,omitempty"`
}

func (m *CreateKeyResponse) Reset()                    { *m = CreateKeyResponse{} }
func (m *CreateKeyResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateKeyResponse) ProtoMessage()               {}
func (*CreateKeyResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *CreateKeyResponse) GetXpub() *XPub {
	if m != nil {
		return m.Xpub
	}
	return nil
}

func (m *CreateKeyResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ListKeysQuery struct {
	Aliases []string `protobuf:"bytes,1,rep,name=aliases" json:"aliases,omitempty"`
	After   string   `protobuf:"bytes,2,opt,name=after" json:"after,omitempty"`
}

func (m *ListKeysQuery) Reset()                    { *m = ListKeysQuery{} }
func (m *ListKeysQuery) String() string            { return proto.CompactTextString(m) }
func (*ListKeysQuery) ProtoMessage()               {}
func (*ListKeysQuery) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *ListKeysQuery) GetAliases() []string {
	if m != nil {
		return m.Aliases
	}
	return nil
}

func (m *ListKeysQuery) GetAfter() string {
	if m != nil {
		return m.After
	}
	return ""
}

type ListKeysResponse struct {
	Items    []*XPub        `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
	LastPage bool           `protobuf:"varint,2,opt,name=last_page,json=lastPage" json:"last_page,omitempty"`
	Next     *ListKeysQuery `protobuf:"bytes,3,opt,name=next" json:"next,omitempty"`
	Error    *Error         `protobuf:"bytes,9,opt,name=error" json:"error,omitempty"`
}

func (m *ListKeysResponse) Reset()                    { *m = ListKeysResponse{} }
func (m *ListKeysResponse) String() string            { return proto.CompactTextString(m) }
func (*ListKeysResponse) ProtoMessage()               {}
func (*ListKeysResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *ListKeysResponse) GetItems() []*XPub {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *ListKeysResponse) GetLastPage() bool {
	if m != nil {
		return m.LastPage
	}
	return false
}

func (m *ListKeysResponse) GetNext() *ListKeysQuery {
	if m != nil {
		return m.Next
	}
	return nil
}

func (m *ListKeysResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type DeleteKeyRequest struct {
	Xpub []byte `protobuf:"bytes,1,opt,name=xpub,proto3" json:"xpub,omitempty"`
}

func (m *DeleteKeyRequest) Reset()                    { *m = DeleteKeyRequest{} }
func (m *DeleteKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteKeyRequest) ProtoMessage()               {}
func (*DeleteKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *DeleteKeyRequest) GetXpub() []byte {
	if m != nil {
		return m.Xpub
	}
	return nil
}

type SignTxsRequest struct {
	Transactions []*TxTemplate `protobuf:"bytes,1,rep,name=transactions" json:"transactions,omitempty"`
	Xpubs        []string      `protobuf:"bytes,2,rep,name=xpubs" json:"xpubs,omitempty"`
}

func (m *SignTxsRequest) Reset()                    { *m = SignTxsRequest{} }
func (m *SignTxsRequest) String() string            { return proto.CompactTextString(m) }
func (*SignTxsRequest) ProtoMessage()               {}
func (*SignTxsRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *SignTxsRequest) GetTransactions() []*TxTemplate {
	if m != nil {
		return m.Transactions
	}
	return nil
}

func (m *SignTxsRequest) GetXpubs() []string {
	if m != nil {
		return m.Xpubs
	}
	return nil
}

func init() {
	proto.RegisterType((*XPub)(nil), "pb.XPub")
	proto.RegisterType((*CreateKeyRequest)(nil), "pb.CreateKeyRequest")
	proto.RegisterType((*CreateKeyResponse)(nil), "pb.CreateKeyResponse")
	proto.RegisterType((*ListKeysQuery)(nil), "pb.ListKeysQuery")
	proto.RegisterType((*ListKeysResponse)(nil), "pb.ListKeysResponse")
	proto.RegisterType((*DeleteKeyRequest)(nil), "pb.DeleteKeyRequest")
	proto.RegisterType((*SignTxsRequest)(nil), "pb.SignTxsRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for HSM service

type HSMClient interface {
	CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*CreateKeyResponse, error)
	ListKeys(ctx context.Context, in *ListKeysQuery, opts ...grpc.CallOption) (*ListKeysResponse, error)
	DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	SignTxs(ctx context.Context, in *SignTxsRequest, opts ...grpc.CallOption) (*TxsResponse, error)
}

type hSMClient struct {
	cc *grpc.ClientConn
}

func NewHSMClient(cc *grpc.ClientConn) HSMClient {
	return &hSMClient{cc}
}

func (c *hSMClient) CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*CreateKeyResponse, error) {
	out := new(CreateKeyResponse)
	err := grpc.Invoke(ctx, "/pb.HSM/CreateKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hSMClient) ListKeys(ctx context.Context, in *ListKeysQuery, opts ...grpc.CallOption) (*ListKeysResponse, error) {
	out := new(ListKeysResponse)
	err := grpc.Invoke(ctx, "/pb.HSM/ListKeys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hSMClient) DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	out := new(ErrorResponse)
	err := grpc.Invoke(ctx, "/pb.HSM/DeleteKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hSMClient) SignTxs(ctx context.Context, in *SignTxsRequest, opts ...grpc.CallOption) (*TxsResponse, error) {
	out := new(TxsResponse)
	err := grpc.Invoke(ctx, "/pb.HSM/SignTxs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for HSM service

type HSMServer interface {
	CreateKey(context.Context, *CreateKeyRequest) (*CreateKeyResponse, error)
	ListKeys(context.Context, *ListKeysQuery) (*ListKeysResponse, error)
	DeleteKey(context.Context, *DeleteKeyRequest) (*ErrorResponse, error)
	SignTxs(context.Context, *SignTxsRequest) (*TxsResponse, error)
}

func RegisterHSMServer(s *grpc.Server, srv HSMServer) {
	s.RegisterService(&_HSM_serviceDesc, srv)
}

func _HSM_CreateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HSMServer).CreateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.HSM/CreateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HSMServer).CreateKey(ctx, req.(*CreateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HSM_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HSMServer).ListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.HSM/ListKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HSMServer).ListKeys(ctx, req.(*ListKeysQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _HSM_DeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HSMServer).DeleteKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.HSM/DeleteKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HSMServer).DeleteKey(ctx, req.(*DeleteKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HSM_SignTxs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignTxsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HSMServer).SignTxs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.HSM/SignTxs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HSMServer).SignTxs(ctx, req.(*SignTxsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _HSM_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.HSM",
	HandlerType: (*HSMServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateKey",
			Handler:    _HSM_CreateKey_Handler,
		},
		{
			MethodName: "ListKeys",
			Handler:    _HSM_ListKeys_Handler,
		},
		{
			MethodName: "DeleteKey",
			Handler:    _HSM_DeleteKey_Handler,
		},
		{
			MethodName: "SignTxs",
			Handler:    _HSM_SignTxs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hsm.proto",
}

func init() { proto.RegisterFile("hsm.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 415 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x52, 0x4d, 0x8b, 0x13, 0x41,
	0x10, 0x75, 0xf2, 0xe1, 0x4e, 0x97, 0x71, 0x4d, 0x8a, 0x08, 0xc3, 0x28, 0xba, 0x0c, 0x28, 0x73,
	0x0a, 0x4b, 0x44, 0x0f, 0x5e, 0x3c, 0xa8, 0x20, 0xac, 0xc2, 0xda, 0x9b, 0x83, 0x78, 0x91, 0x9e,
	0xa5, 0x8c, 0x03, 0xf3, 0xd1, 0x76, 0xf7, 0xc0, 0xe4, 0x97, 0xf8, 0xff, 0xfc, 0x25, 0xd2, 0xdd,
	0x99, 0x64, 0x26, 0x0a, 0xde, 0xba, 0x5e, 0x55, 0xbd, 0x7a, 0xf5, 0xaa, 0x81, 0xfd, 0xd0, 0xe5,
	0x4a, 0xaa, 0xda, 0xd4, 0x38, 0x92, 0x59, 0x3c, 0xbb, 0xad, 0xcb, 0xb2, 0xae, 0x3c, 0x12, 0x33,
	0x21, 0xa5, 0x7f, 0x26, 0x97, 0x30, 0xf9, 0x72, 0xdd, 0x64, 0xb8, 0x84, 0xa9, 0x28, 0x72, 0xa1,
	0xa3, 0xe0, 0x22, 0x48, 0x19, 0xf7, 0x01, 0x22, 0x4c, 0x5a, 0xd9, 0x64, 0xd1, 0xe8, 0x22, 0x48,
	0x67, 0xdc, 0xbd, 0x93, 0x14, 0xe6, 0x6f, 0x15, 0x09, 0x43, 0x57, 0xb4, 0xe3, 0xf4, 0xb3, 0x21,
	0x6d, 0xfe, 0xdd, 0x9d, 0x70, 0x58, 0xf4, 0x2a, 0xb5, 0xac, 0x2b, 0x4d, 0xf8, 0x78, 0x4f, 0x69,
	0x2b, 0xef, 0xad, 0xc3, 0x95, 0xcc, 0x56, 0x56, 0x80, 0x27, 0xc7, 0xa7, 0x30, 0x25, 0xa5, 0x6a,
	0x15, 0x31, 0x97, 0x66, 0x36, 0xfd, 0xde, 0x02, 0xdc, 0xe3, 0xc9, 0x1b, 0xb8, 0xff, 0x31, 0xd7,
	0xe6, 0x8a, 0x76, 0xfa, 0x73, 0x43, 0x6a, 0x87, 0x11, 0x9c, 0xb9, 0x69, 0x64, 0x87, 0x8f, 0x53,
	0xc6, 0xbb, 0xd0, 0x89, 0xfa, 0x6e, 0x48, 0x39, 0xf5, 0x56, 0x94, 0x0d, 0x92, 0x5f, 0x01, 0xcc,
	0x3b, 0x86, 0x83, 0xa8, 0x27, 0x30, 0xcd, 0x0d, 0x95, 0x9e, 0xa2, 0xaf, 0xca, 0xc3, 0xf8, 0x08,
	0x58, 0x21, 0xb4, 0xf9, 0x26, 0xc5, 0x96, 0x1c, 0x5d, 0xc8, 0x43, 0x0b, 0x5c, 0x8b, 0x2d, 0xe1,
	0x33, 0x98, 0x54, 0xd4, 0x9a, 0x68, 0xec, 0x24, 0x2f, 0x6c, 0xef, 0x40, 0x22, 0x77, 0xe9, 0xff,
	0xaf, 0xf6, 0x1c, 0xe6, 0xef, 0xa8, 0xa0, 0x81, 0xb1, 0xd8, 0x73, 0xab, 0x3b, 0xc0, 0x57, 0x38,
	0xbf, 0xc9, 0xb7, 0xd5, 0xa6, 0xd5, 0x5d, 0xd5, 0x1a, 0x66, 0x46, 0x89, 0x4a, 0x8b, 0x5b, 0x93,
	0xd7, 0x55, 0xb7, 0xc5, 0xb9, 0x9d, 0xb0, 0x69, 0x37, 0x54, 0xca, 0x42, 0x18, 0xe2, 0x83, 0x1a,
	0xeb, 0x8e, 0x65, 0xd3, 0xd1, 0xc8, 0xb9, 0xe6, 0x83, 0xf5, 0xef, 0x00, 0xc6, 0x1f, 0x6e, 0x3e,
	0xe1, 0x6b, 0x60, 0x87, 0xd3, 0xe1, 0xd2, 0x12, 0x9d, 0xde, 0x3c, 0x7e, 0x78, 0x82, 0x7a, 0x2b,
	0x93, 0x3b, 0xf8, 0x12, 0xc2, 0x6e, 0x7f, 0xfc, 0xdb, 0x8d, 0x78, 0xd9, 0x87, 0x7a, 0x6d, 0xaf,
	0x80, 0x1d, 0xd6, 0xf7, 0x23, 0x4f, 0xdd, 0x88, 0x17, 0x47, 0xcf, 0x8e, 0x7d, 0x97, 0x70, 0xb6,
	0xb7, 0x03, 0xd1, 0xe6, 0x87, 0xde, 0xc4, 0x0f, 0xbc, 0x0b, 0xbd, 0x49, 0xd9, 0x5d, 0xf7, 0xf5,
	0x5f, 0xfc, 0x09, 0x00, 0x00, 0xff, 0xff, 0xb4, 0xd9, 0xd2, 0x4f, 0x24, 0x03, 0x00, 0x00,
}
